<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data structures and agorithms notes</title>
    <style>
        body{
            padding: 0 20px;
        }
        h1,h2,h3,h4,h5{
            text-align: center;
            text-transform: uppercase;
            color: blue;
        }
        p::first-letter{
            text-transform:uppercase;
        }
    </style>
</head>
<body>
    <h1>JAVASCRIPT ALGORITHMS</h1>
    <p>Hi, My name is Diana. I made these notes to help me understand javascript data structres and algorithms. Hope they help you too ðŸ˜Š.</p>
    <h5>what is an algorithm?</h5>
    <p>An algorithm is a set of well-defined instructions to solve a particuar problem</p>
    <h5>Recipe analogy</h5>
    <p>you have (ingredients) follow the (recipe) and make a (tasty dish)</p>
    <p>in programming consider algorithm to add two numbers the two numbers are the ingredients (input) steps to adding the two numbers is using + operator to return a value (recipe) the output is the sum of the two numbers (tasty dish) </p>
    <p>input -> algorithm -> output</p>

    <h2>characteristics of an algorithm</h2>
    <ul>
        <li>Should have well defined inputs and outputs</li>
        <li>Each step should be clear and unambiguos</li>
        <li>It should be language independent i.e can be used with any programming language</li>

    </ul>
    <h2>why learn algorithm?</h2>
    <p>- As a developer you are going to come across problems that you need to solve</p>
    <p>- Learning algorithms translates to learning different techniques to efficiently solve those problems</p>
    <p>- One problem can be solved in many ways using different algorithms</p>
    <p>- Every algorithm comes with its own tradeoffs when it comes to performance</p>

    <h2>Algorithms analysis</h2>
    <p>How do we measure algorithms?</p>
    <p>ex.There are multiple algorithms to sort a list of numbers</p>
    <p>how do you analyse which one of them is the most efficient algorithm?</p>
    <p>generally when we talk about performance, we use an absolute measure</p>
    <p>The absolute running time of an algorithm cannot be predicted, since it depends on a number of factors</p>
    <ol>
        <li>Programming language used to implement the algorithm</li>
        <li>The computer the program runs on</li>
        <li>Other programs running at the same time</li>
        <li>Quality of the operating system</li>
    </ol>
    <p>keeping this in mind, we evaluate the performance of an algorithm <b>in terms of its input size</b></p>
    <p>evaluation is of two types</p>
    <p><b>time complexity</b> - amount of time taken by an algorithm to run, as a function of input size </p>
    <p><b>space complexity</b> - amount of memory taken by an algorithm to run, as a function of input size</p>
    <br><br>

    <p>by evaluating against the input size, the analysis is not only machine independent but the comparison is also more appropriate</p>
    <p>there is no one solution that works every single time. It is always goood to know multiple ways to solve the problem and use the best solution, given your constraints</p>
    <p>if your app need to be quick and has plenty of memory to work with, you dont need to worry about space complexity</p>
    <p>if you have very little memory to work with, you should pick a solution that is relatively slower but needs less space</p>

  <h2>how to represent complexity</h2>
  <p>we use Asymptotic notations <br>
    - Asymptotic notations are mathematical tools to represent time and space complexity
</p>
<ol>
    <li>Big-O notation (O - notation) - worst case complexity </li>
    <li>Omega notation (&Omega; - notation) - best case complexity </li>
    <li>Theta notation (&Theta; - notation ) - average case complexity</li>
</ol>

<h2>Big-O Notation</h2>
<p>worst case complexity of an algorithm is represented using the Big-O notation </p>
<p style="color:red">Most of the interviewers will ask about the Big-O</p>
<p>it describes the complexity of an algorithm using algebraic terms</p>
<p>it has two important characteristics</p>
<ul>
    <li>It is expressed in terms of the input</li>
    <li>It focuses on the bigger picture without getting caught up in the minute details</li>
</ul> 

<p><b>in the example:</b> </p>
<p>
    function add(n){<br>
        sum = 0; ----------------- 1 (executed once) <br>
        for(let i=1; 1<=n; i++){<br>
            sum+=i -----------------4 (executed 4 times)
        }<br>
        return sum ---------------  1 (executed once)<br>
    }<br>
    n = 4 <br>
    Big-O is (n+2)
    <p>
        if <br>
        n= 100 -------------->> 100+2<br>
        n= 1000 -------------->> 1000+2<br>
        n= 10000 ------------>> 10000+2<br>
        .<br>
        .<br>
        .<br>
        n = 10000000 ------------>> 1000000+2<br>
        At this point 2 becomes insignificant so instead of having n+2 we do away with the 2 and remain with n since it contributes the most to the total value and not the additional 2 steps
    </p>
    <p>from our example above the Big-O time complexity is represented by <b>O(n) -linear.</b>  This means that as the size of the input increases so will the time complexity increase</p>
    <p>most of the time you come across a loop in your algorithm you can say that the time complexity is O(n) - linear complexity</p>

    <h3>BIG-O calculation</h3>
    <p><b>Example 1</b></p>
    <p>function sumation(n){<br>
        return (n* (n+1))/2 <br>
    }
    </p>
    <p>the time compexity is <b>O(1) - constant</b></p>
    <p>---------------------------------------------------------------------------------------------------------</p>
   <p><b>Example 2:</b></p>
    <p>
        for(i=1; i<=n; i++){<br>
            for(j=1; j<=i; j++){<br>
                //some code
            }
        }<br>
    </p>
    <p>Time compexity is <b>O(n^2) - quadratic</b><br>
    3n^2 + 5n + 1</p>
</p>

<p>If there are 3 loops nested time complexity will be <b> O(n^3) - Cubic</b></p>
<p>If the input size reduces by half every iteration time complexity will be <b> O(log n) - logarithmic</b></p><br>

<h2>SPACE COMPEXITY</h2>
<p>The idea remains the same as time complexity. If the algorithm doesnt need extra memory or the memory needed does not depend on the input size the space complexity is<br> <b> O(1) - constant. </b><br>
<b>we also have O(n) - linear space complexity</b><br>
<b>and O(logn) - logarithmic space complexity</b></p>

<h2>Big O trend</h2>
<p>visit this site : <a href="https://www.bigocheatsheet.com/">click here</a> to see how input size affects performance </p>
<p>You will notice that the performance on <b>O(log n) - logarithmic and O(1) - constant is good compared to O(n!) -factorial which is horrible and should be avoided if possible</b></p>

<h5>few points to note</h5>
<p>multipe algorithms exist for the same problem and there is no one right solution. Different agorithms work well under different contraints</p>
<p>The same algorithm with the same programming language can be implemented in different ways</p>
<p>when writing programs, dont lose sight of the big picture. Rather than writing clever code, write code that is simple to read and maintain.</p>

<h2>objects -big-o</h2>
<p>an object is a collection of key value pairs</p>
<p><b>example:</b></p>
<p>
    const person = {<br>
        firstname: 'Diana',<br>
        lastname: 'Nyamai'<br>
    }
</p>
<p>if you want to remove or insert a new property the time complexity is <b>O(1) - constant</b> </p>
<p>if you want to access a value given a key the time complexity is <b>O(1) - constant</b></p>
<p>if you want to search a property in an object the time complexity is <b>O(n) - linear</b></p>
<p>using methods on objects will have time complexity of O(n) - linear</p>
 <ul>
    <li>insert - O(1)</li>
    <li>remove - O(1)</li>
    <li>access - O(1)</li>
    <li>search - O(n)</li>
    <li>object.keys() - O(n)</li>
    <li>object.values() - O(n)</li>
    <li>object.entries() - O(n)</li>
 </ul>

 <h2>array - big-o</h2>
 <p>array is an ordered collection of values</p>
 <p><b>example</b></p>
 <p>const arr = [2,4,6,8]</p>
 <p>
    <ul>
        <li>insert/remove at the end - O(1)</li>
        <li>insert/remove at the beginning - O(n) this is beacuse the index has to be reset in every remaining element in the array</li>
        <li>access- O(1) this is because fetching an element in position 0 is no difference from fetching at one in position 100</li>
        <li>search - O(n)</li>
        <li>push/pop - O(1)</li>
        <li>shift/unshift/concat/slice/splice - O(n)</li>
        <li>forEach/map/filter/reduce - O(n)</li>


    </ul>
 </p>

 <h2>Math Algorithms</h2>
 <p><b>problem1:</b> Given a number 'n' find the first 'n' eements of the fibonacci sequence</p>
 <p>in mathematics, the fibonacci sequence is the sequence in which each number is the sum of the preceding ones</p>
 <p>the first two numbers in the sequence are 0 and 1. </p>
 <ul>
    <li>fibonacci(2) = [0,1]</li>
    <li>fibonacci(3) = [0,1,1]</li>
    <li>fibonacci(7) = [0,1,1,2,3,5,8,13]</li>
</ul>
<p><b>solution:</b></p>
<p>function fibonacc(n){<br>
    var fib = [0,1]<br>
    for(let i=2; i < n; i++){ <br>
     fib[i] = fib[i-1] + fib[i-2] <br>
    }<br>
    return fib; <br>
 }<br>
 fibonacc(2)  <br>
 fibonacc(3)  <br></p>

<p><b>problem2:</b></p>
<p>given an integer 'n' find the factorial of that integer</p> 
<p>in mathmatics, the factorial of a non negative inter 'n' denoted as n!, is the products of all positive integers less than or equal to to 'n'</p>
<p>factorial of zero is 1</p>
<p>factorial(4) = 4*3*2*1 = 24</p>
<p><b>solution:</b></p>
<p>
    function factorial(n){<br>
        let res = 1;<br>
        for(let i=1; i<=n; i++){<br>
         res*=i<br>
        }<br>
        return res<br>
     }<br>
     document.write(factorial(4));<br>
     document.write(factorial(8));
</p>
<P style="color: green;">solved this on my own. lol:)</P>

<p><b>problem3:</b></p>
<p>given a natural number 'n', determine if the nmber is prime or not</p>
<p>A prime number isa natural number greater than 1 that is not a product of two smaller natural numbers.</p>
<p>isPrime(5) = true(1*5 or 5*1)</p>
<p>isPrime(4) = false(1*4 or 2*2 or 4*1)</p>
<p><b>solution:</b></p>
<p>function isPrime(n){ <br>
    if(n<2){ <br>
      return false <br>
    }<br>
    for(let i=2; i < n; i++){ <br>
      if(n%i === 0){<br>
          return false; <br>
      }<br>
    }<br>
    return true;<br>
  }<br>
  document.write(isPrime(5) ) <br>
  document.write(isPrime(10) )</p>



</body>
</html>